<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The `ERR` Constant (TBB Error Sentinel) - Aria Programming Guide</title>
    <style>
        :root {
            --bg-main: #1e1e1e;
            --bg-code: #2d2d2d;
            --bg-sidebar: #252526;
            --text-main: #d4d4d4;
            --text-dim: #808080;
            --accent: #4ec9b0;
            --accent-hover: #6fdfca;
            --link: #569cd6;
            --border: #3e3e42;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-main);
            color: var(--text-main);
            line-height: 1.6;
            display: flex;
        }
        
        /* Sidebar navigation */
        nav {
            width: 280px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            padding: 20px;
        }
        
        nav h2 {
            color: var(--accent);
            font-size: 1.5em;
            margin-bottom: 20px;
        }
        
        nav .category {
            margin-bottom: 20px;
        }
        
        nav .category h3 {
            color: var(--text-dim);
            font-size: 0.9em;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }
        
        nav ul {
            list-style: none;
        }
        
        nav a {
            color: var(--text-main);
            text-decoration: none;
            display: block;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.95em;
            transition: all 0.2s;
        }
        
        nav a:hover {
            background: var(--bg-code);
            color: var(--accent-hover);
        }
        
        nav a.active {
            background: var(--accent);
            color: var(--bg-main);
            font-weight: 500;
        }
        
        /* Main content */
        main {
            margin-left: 280px;
            padding: 40px 60px;
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            color: var(--accent);
            font-size: 2.5em;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 15px;
        }
        
        h2 {
            color: var(--accent);
            font-size: 1.8em;
            margin-top: 40px;
            margin-bottom: 20px;
        }
        
        h3 {
            color: var(--text-main);
            font-size: 1.3em;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        p {
            margin-bottom: 15px;
            color: var(--text-main);
        }
        
        code {
            background: var(--bg-code);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: var(--accent);
        }
        
        pre {
            background: var(--bg-code);
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 3px solid var(--accent);
        }
        
        pre code {
            background: none;
            padding: 0;
            color: var(--text-main);
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        a {
            color: var(--link);
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid var(--border);
        }
        
        th {
            background: var(--bg-code);
            color: var(--accent);
            font-weight: 600;
        }
        
        blockquote {
            border-left: 4px solid var(--accent);
            padding-left: 20px;
            margin: 20px 0;
            color: var(--text-dim);
            font-style: italic;
        }
        
        hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 30px 0;
        }
        
        .breadcrumb {
            color: var(--text-dim);
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        
        .breadcrumb a {
            color: var(--text-dim);
        }
        
        .breadcrumb a:hover {
            color: var(--accent);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            nav {
                display: none;
            }
            main {
                margin-left: 0;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <nav>
        <h2>Aria Guide</h2>
        <div class="category">
<h3>General</h3>
<ul>
<li><a href="/SYNTAX_AUDIT_FEB14_2026.html">Syntax Audit Feb14 2026</a></li>
<li><a href="/UPDATE_PROGRESS.html">Update Progress</a></li>
</ul>
</div>
<div class="category">
<h3>Meta</h3>
<ul>
<li><a href="/META/ARIA/SYNTAX_REFERENCE.html">Syntax Reference</a></li>
</ul>
</div>
<div class="category">
<h3>Advanced Features</h3>
<ul>
<li><a href="/advanced_features/ast.html">Ast</a></li>
<li><a href="/advanced_features/async.html">Async</a></li>
<li><a href="/advanced_features/async_await.html">Async Await</a></li>
<li><a href="/advanced_features/atomics.html">Atomics</a></li>
<li><a href="/advanced_features/await.html">Await</a></li>
<li><a href="/advanced_features/best_practices.html">Best Practices</a></li>
<li><a href="/advanced_features/brace_delimited.html">Brace Delimited</a></li>
<li><a href="/advanced_features/code_examples.html">Code Examples</a></li>
<li><a href="/advanced_features/colons.html">Colons</a></li>
<li><a href="/advanced_features/comments.html">Comments</a></li>
<li><a href="/advanced_features/common_patterns.html">Common Patterns</a></li>
<li><a href="/advanced_features/compile_time.html">Compile Time</a></li>
<li><a href="/advanced_features/comptime.html">Comptime</a></li>
<li><a href="/advanced_features/concurrency.html">Concurrency</a></li>
<li><a href="/advanced_features/const.html">Const</a></li>
<li><a href="/advanced_features/context_stack.html">Context Stack</a></li>
<li><a href="/advanced_features/coroutines.html">Coroutines</a></li>
<li><a href="/advanced_features/destructuring.html">Destructuring</a></li>
<li><a href="/advanced_features/error_handling.html">Error Handling</a></li>
<li><a href="/advanced_features/error_propagation.html">Error Propagation</a></li>
<li><a href="/advanced_features/idioms.html">Idioms</a></li>
<li><a href="/advanced_features/lexer.html">Lexer</a></li>
<li><a href="/advanced_features/macros.html">Macros</a></li>
<li><a href="/advanced_features/metaprogramming.html">Metaprogramming</a></li>
<li><a href="/advanced_features/multiline_comments.html">Multiline Comments</a></li>
<li><a href="/advanced_features/nasm_macros.html">Nasm Macros</a></li>
<li><a href="/advanced_features/parser.html">Parser</a></li>
<li><a href="/advanced_features/pattern_matching.html">Pattern Matching</a></li>
<li><a href="/advanced_features/semicolons.html">Semicolons</a></li>
<li><a href="/advanced_features/threading.html">Threading</a></li>
<li><a href="/advanced_features/tokens.html">Tokens</a></li>
<li><a href="/advanced_features/whitespace_insensitive.html">Whitespace Insensitive</a></li>
</ul>
</div>
<div class="category">
<h3>Control Flow</h3>
<ul>
<li><a href="/control_flow/break.html">Break</a></li>
<li><a href="/control_flow/continue.html">Continue</a></li>
<li><a href="/control_flow/dollar_variable.html">Dollar Variable</a></li>
<li><a href="/control_flow/fail.html">Fail</a></li>
<li><a href="/control_flow/fall.html">Fall</a></li>
<li><a href="/control_flow/fallthrough.html">Fallthrough</a></li>
<li><a href="/control_flow/for.html">For</a></li>
<li><a href="/control_flow/for_syntax.html">For Syntax</a></li>
<li><a href="/control_flow/if_else.html">If Else</a></li>
<li><a href="/control_flow/if_syntax.html">If Syntax</a></li>
<li><a href="/control_flow/iteration_variable.html">Iteration Variable</a></li>
<li><a href="/control_flow/loop.html">Loop</a></li>
<li><a href="/control_flow/loop_direction.html">Loop Direction</a></li>
<li><a href="/control_flow/loop_syntax.html">Loop Syntax</a></li>
<li><a href="/control_flow/pass.html">Pass</a></li>
<li><a href="/control_flow/pick.html">Pick</a></li>
<li><a href="/control_flow/pick_patterns.html">Pick Patterns</a></li>
<li><a href="/control_flow/pick_syntax.html">Pick Syntax</a></li>
<li><a href="/control_flow/till.html">Till</a></li>
<li><a href="/control_flow/till_direction.html">Till Direction</a></li>
<li><a href="/control_flow/till_syntax.html">Till Syntax</a></li>
<li><a href="/control_flow/when_syntax.html">When Syntax</a></li>
<li><a href="/control_flow/when_then.html">When Then</a></li>
<li><a href="/control_flow/when_then_end.html">When Then End</a></li>
<li><a href="/control_flow/while.html">While</a></li>
<li><a href="/control_flow/while_syntax.html">While Syntax</a></li>
</ul>
</div>
<div class="category">
<h3>Debugging</h3>
<ul>
<li><a href="/debugging/dbug.html">Dbug</a></li>
</ul>
</div>
<div class="category">
<h3>Functions</h3>
<ul>
<li><a href="/functions/anonymous_functions.html">Anonymous Functions</a></li>
<li><a href="/functions/async_functions.html">Async Functions</a></li>
<li><a href="/functions/async_keyword.html">Async Keyword</a></li>
<li><a href="/functions/closure_capture.html">Closure Capture</a></li>
<li><a href="/functions/closures.html">Closures</a></li>
<li><a href="/functions/fail_keyword.html">Fail Keyword</a></li>
<li><a href="/functions/func_keyword.html">Func Keyword</a></li>
<li><a href="/functions/function_arguments.html">Function Arguments</a></li>
<li><a href="/functions/function_declaration.html">Function Declaration</a></li>
<li><a href="/functions/function_params.html">Function Params</a></li>
<li><a href="/functions/function_return_type.html">Function Return Type</a></li>
<li><a href="/functions/function_syntax.html">Function Syntax</a></li>
<li><a href="/functions/generic_functions.html">Generic Functions</a></li>
<li><a href="/functions/generic_parameters.html">Generic Parameters</a></li>
<li><a href="/functions/generic_star_prefix.html">Generic Star Prefix</a></li>
<li><a href="/functions/generic_structs.html">Generic Structs</a></li>
<li><a href="/functions/generic_syntax.html">Generic Syntax</a></li>
<li><a href="/functions/generic_types.html">Generic Types</a></li>
<li><a href="/functions/generics.html">Generics</a></li>
<li><a href="/functions/higher_order_functions.html">Higher Order Functions</a></li>
<li><a href="/functions/immediate_execution.html">Immediate Execution</a></li>
<li><a href="/functions/lambda.html">Lambda</a></li>
<li><a href="/functions/lambda_syntax.html">Lambda Syntax</a></li>
<li><a href="/functions/monomorphization.html">Monomorphization</a></li>
<li><a href="/functions/multiple_generics.html">Multiple Generics</a></li>
<li><a href="/functions/pass_keyword.html">Pass Keyword</a></li>
<li><a href="/functions/type_inference.html">Type Inference</a></li>
</ul>
</div>
<div class="category">
<h3>Io System</h3>
<ul>
<li><a href="/io_system/binary_io.html">Binary Io</a></li>
<li><a href="/io_system/control_plane.html">Control Plane</a></li>
<li><a href="/io_system/data_plane.html">Data Plane</a></li>
<li><a href="/io_system/debug_io.html">Debug Io</a></li>
<li><a href="/io_system/hex_stream.html">Hex Stream</a></li>
<li><a href="/io_system/io_overview.html">Io Overview</a></li>
<li><a href="/io_system/six_stream_topology.html">Six Stream Topology</a></li>
<li><a href="/io_system/stddati.html">Stddati</a></li>
<li><a href="/io_system/stddato.html">Stddato</a></li>
<li><a href="/io_system/stddbg.html">Stddbg</a></li>
<li><a href="/io_system/stderr.html">Stderr</a></li>
<li><a href="/io_system/stdin.html">Stdin</a></li>
<li><a href="/io_system/stdout.html">Stdout</a></li>
<li><a href="/io_system/stream_separation.html">Stream Separation</a></li>
<li><a href="/io_system/text_io.html">Text Io</a></li>
</ul>
</div>
<div class="category">
<h3>Memory Model</h3>
<ul>
<li><a href="/memory_model/address_operator.html">Address Operator</a></li>
<li><a href="/memory_model/allocation.html">Allocation</a></li>
<li><a href="/memory_model/allocators.html">Allocators</a></li>
<li><a href="/memory_model/aria_alloc.html">Aria Alloc</a></li>
<li><a href="/memory_model/aria_alloc_array.html">Aria Alloc Array</a></li>
<li><a href="/memory_model/aria_alloc_buffer.html">Aria Alloc Buffer</a></li>
<li><a href="/memory_model/aria_alloc_string.html">Aria Alloc String</a></li>
<li><a href="/memory_model/aria_free.html">Aria Free</a></li>
<li><a href="/memory_model/aria_gc_alloc.html">Aria Gc Alloc</a></li>
<li><a href="/memory_model/borrow_operator.html">Borrow Operator</a></li>
<li><a href="/memory_model/borrowing.html">Borrowing</a></li>
<li><a href="/memory_model/defer.html">Defer</a></li>
<li><a href="/memory_model/gc.html">Gc</a></li>
<li><a href="/memory_model/immutable_borrow.html">Immutable Borrow</a></li>
<li><a href="/memory_model/mutable_borrow.html">Mutable Borrow</a></li>
<li><a href="/memory_model/pin_operator.html">Pin Operator</a></li>
<li><a href="/memory_model/pinning.html">Pinning</a></li>
<li><a href="/memory_model/pointer_syntax.html">Pointer Syntax</a></li>
<li><a href="/memory_model/raii.html">Raii</a></li>
<li><a href="/memory_model/stack.html">Stack</a></li>
</ul>
</div>
<div class="category">
<h3>Modules</h3>
<ul>
<li><a href="/modules/c_interop.html">C Interop</a></li>
<li><a href="/modules/c_pointers.html">C Pointers</a></li>
<li><a href="/modules/cfg.html">Cfg</a></li>
<li><a href="/modules/conditional_compilation.html">Conditional Compilation</a></li>
<li><a href="/modules/extern.html">Extern</a></li>
<li><a href="/modules/extern_blocks.html">Extern Blocks</a></li>
<li><a href="/modules/extern_functions.html">Extern Functions</a></li>
<li><a href="/modules/extern_syntax.html">Extern Syntax</a></li>
<li><a href="/modules/ffi.html">Ffi</a></li>
<li><a href="/modules/libc_integration.html">Libc Integration</a></li>
<li><a href="/modules/mod.html">Mod</a></li>
<li><a href="/modules/mod_keyword.html">Mod Keyword</a></li>
<li><a href="/modules/module_aliases.html">Module Aliases</a></li>
<li><a href="/modules/module_definition.html">Module Definition</a></li>
<li><a href="/modules/module_paths.html">Module Paths</a></li>
<li><a href="/modules/nested_modules.html">Nested Modules</a></li>
<li><a href="/modules/pub.html">Pub</a></li>
<li><a href="/modules/public_visibility.html">Public Visibility</a></li>
<li><a href="/modules/use.html">Use</a></li>
<li><a href="/modules/use_syntax.html">Use Syntax</a></li>
</ul>
</div>
<div class="category">
<h3>Operators</h3>
<ul>
<li><a href="/operators/add.html">Add</a></li>
<li><a href="/operators/add_assign.html">Add Assign</a></li>
<li><a href="/operators/address.html">Address</a></li>
<li><a href="/operators/ampersand.html">Ampersand</a></li>
<li><a href="/operators/and_assign.html">And Assign</a></li>
<li><a href="/operators/arrow.html">Arrow</a></li>
<li><a href="/operators/assign.html">Assign</a></li>
<li><a href="/operators/at_operator.html">At Operator</a></li>
<li><a href="/operators/backtick.html">Backtick</a></li>
<li><a href="/operators/bitwise_and.html">Bitwise And</a></li>
<li><a href="/operators/bitwise_not.html">Bitwise Not</a></li>
<li><a href="/operators/bitwise_or.html">Bitwise Or</a></li>
<li><a href="/operators/bitwise_xor.html">Bitwise Xor</a></li>
<li><a href="/operators/colon.html">Colon</a></li>
<li><a href="/operators/decrement.html">Decrement</a></li>
<li><a href="/operators/div_assign.html">Div Assign</a></li>
<li><a href="/operators/divide.html">Divide</a></li>
<li><a href="/operators/dollar_operator.html">Dollar Operator</a></li>
<li><a href="/operators/dollar_variable.html">Dollar Variable</a></li>
<li><a href="/operators/dot.html">Dot</a></li>
<li><a href="/operators/equal.html">Equal</a></li>
<li><a href="/operators/greater_equal.html">Greater Equal</a></li>
<li><a href="/operators/greater_than.html">Greater Than</a></li>
<li><a href="/operators/hash_operator.html">Hash Operator</a></li>
<li><a href="/operators/increment.html">Increment</a></li>
<li><a href="/operators/interpolation.html">Interpolation</a></li>
<li><a href="/operators/is_operator.html">Is Operator</a></li>
<li><a href="/operators/is_ternary.html">Is Ternary</a></li>
<li><a href="/operators/iteration.html">Iteration</a></li>
<li><a href="/operators/left_shift.html">Left Shift</a></li>
<li><a href="/operators/less_equal.html">Less Equal</a></li>
<li><a href="/operators/less_than.html">Less Than</a></li>
<li><a href="/operators/logical_and.html">Logical And</a></li>
<li><a href="/operators/logical_not.html">Logical Not</a></li>
<li><a href="/operators/logical_or.html">Logical Or</a></li>
<li><a href="/operators/lshift_assign.html">Lshift Assign</a></li>
<li><a href="/operators/member_access.html">Member Access</a></li>
<li><a href="/operators/minus.html">Minus</a></li>
<li><a href="/operators/minus_assign.html">Minus Assign</a></li>
<li><a href="/operators/mod_assign.html">Mod Assign</a></li>
<li><a href="/operators/modulo.html">Modulo</a></li>
<li><a href="/operators/mul_assign.html">Mul Assign</a></li>
<li><a href="/operators/mult_assign.html">Mult Assign</a></li>
<li><a href="/operators/multiply.html">Multiply</a></li>
<li><a href="/operators/not_equal.html">Not Equal</a></li>
<li><a href="/operators/null_coalesce.html">Null Coalesce</a></li>
<li><a href="/operators/null_coalescing.html">Null Coalescing</a></li>
<li><a href="/operators/or_assign.html">Or Assign</a></li>
<li><a href="/operators/pin.html">Pin</a></li>
<li><a href="/operators/pipe_backward.html">Pipe Backward</a></li>
<li><a href="/operators/pipe_forward.html">Pipe Forward</a></li>
<li><a href="/operators/pipeline.html">Pipeline</a></li>
<li><a href="/operators/plus.html">Plus</a></li>
<li><a href="/operators/plus_assign.html">Plus Assign</a></li>
<li><a href="/operators/pointer_member.html">Pointer Member</a></li>
<li><a href="/operators/question_operator.html">Question Operator</a></li>
<li><a href="/operators/range.html">Range</a></li>
<li><a href="/operators/range_exclusive.html">Range Exclusive</a></li>
<li><a href="/operators/range_inclusive.html">Range Inclusive</a></li>
<li><a href="/operators/right_shift.html">Right Shift</a></li>
<li><a href="/operators/rshift_assign.html">Rshift Assign</a></li>
<li><a href="/operators/safe_nav.html">Safe Nav</a></li>
<li><a href="/operators/safe_navigation.html">Safe Navigation</a></li>
<li><a href="/operators/spaceship.html">Spaceship</a></li>
<li><a href="/operators/string_interpolation.html">String Interpolation</a></li>
<li><a href="/operators/sub_assign.html">Sub Assign</a></li>
<li><a href="/operators/subtract.html">Subtract</a></li>
<li><a href="/operators/template_literal.html">Template Literal</a></li>
<li><a href="/operators/template_syntax.html">Template Syntax</a></li>
<li><a href="/operators/ternary_is.html">Ternary Is</a></li>
<li><a href="/operators/three_way_comparison.html">Three Way Comparison</a></li>
<li><a href="/operators/type_annotation.html">Type Annotation</a></li>
<li><a href="/operators/unwrap.html">Unwrap</a></li>
<li><a href="/operators/xor_assign.html">Xor Assign</a></li>
</ul>
</div>
<div class="category">
<h3>Standard Library</h3>
<ul>
<li><a href="/standard_library/createLogger.html">Createlogger</a></li>
<li><a href="/standard_library/createPipe.html">Createpipe</a></li>
<li><a href="/standard_library/exec.html">Exec</a></li>
<li><a href="/standard_library/filter.html">Filter</a></li>
<li><a href="/standard_library/fork.html">Fork</a></li>
<li><a href="/standard_library/functional_programming.html">Functional Programming</a></li>
<li><a href="/standard_library/getActiveConnections.html">Getactiveconnections</a></li>
<li><a href="/standard_library/getMemoryUsage.html">Getmemoryusage</a></li>
<li><a href="/standard_library/http_client.html">Http Client</a></li>
<li><a href="/standard_library/httpGet.html">Httpget</a></li>
<li><a href="/standard_library/log_levels.html">Log Levels</a></li>
<li><a href="/standard_library/math.html">Math</a></li>
<li><a href="/standard_library/math_round.html">Math Round</a></li>
<li><a href="/standard_library/openFile.html">Openfile</a></li>
<li><a href="/standard_library/print.html">Print</a></li>
<li><a href="/standard_library/process_management.html">Process Management</a></li>
<li><a href="/standard_library/readCSV.html">Readcsv</a></li>
<li><a href="/standard_library/readFile.html">Readfile</a></li>
<li><a href="/standard_library/readJSON.html">Readjson</a></li>
<li><a href="/standard_library/reverse.html">Reverse</a></li>
<li><a href="/standard_library/sort.html">Sort</a></li>
<li><a href="/standard_library/spawn.html">Spawn</a></li>
<li><a href="/standard_library/stream_io.html">Stream Io</a></li>
<li><a href="/standard_library/structured_logging.html">Structured Logging</a></li>
<li><a href="/standard_library/system_diagnostics.html">System Diagnostics</a></li>
<li><a href="/standard_library/transform.html">Transform</a></li>
<li><a href="/standard_library/unique.html">Unique</a></li>
<li><a href="/standard_library/wait.html">Wait</a></li>
<li><a href="/standard_library/writeFile.html">Writefile</a></li>
</ul>
</div>
<div class="category">
<h3>Stdlib</h3>
<ul>
<li><a href="/stdlib/filter.html">Filter</a></li>
<li><a href="/stdlib/print.html">Print</a></li>
<li><a href="/stdlib/readFile.html">Readfile</a></li>
<li><a href="/stdlib/reduce.html">Reduce</a></li>
<li><a href="/stdlib/transform.html">Transform</a></li>
<li><a href="/stdlib/writeFile.html">Writefile</a></li>
</ul>
</div>
<div class="category">
<h3>Types</h3>
<ul>
<li><a href="/types/Atomic.html">Atomic</a></li>
<li><a href="/types/atomic.html">Atomic</a></li>
<li><a href="/types/balanced_nonary.html">Balanced Nonary</a></li>
<li><a href="/types/balanced_numbers.html">Balanced Numbers</a></li>
<li><a href="/types/balanced_ternary.html">Balanced Ternary</a></li>
<li><a href="/types/bool.html">Bool</a></li>
<li><a href="/types/complex.html">Complex</a></li>
<li><a href="/types/Complex.html">Complex</a></li>
<li><a href="/types/double.html">Double</a></li>
<li><a href="/types/dyn.html">Dyn</a></li>
<li><a href="/types/ERR.html">Err</a></li>
<li><a href="/types/fix256.html">Fix256</a></li>
<li><a href="/types/float.html">Float</a></li>
<li><a href="/types/flt128.html">Flt128</a></li>
<li><a href="/types/flt256.html">Flt256</a></li>
<li><a href="/types/flt32.html">Flt32</a></li>
<li><a href="/types/flt512.html">Flt512</a></li>
<li><a href="/types/flt64.html">Flt64</a></li>
<li><a href="/types/frac16.html">Frac16</a></li>
<li><a href="/types/frac32.html">Frac32</a></li>
<li><a href="/types/frac64.html">Frac64</a></li>
<li><a href="/types/frac8.html">Frac8</a></li>
<li><a href="/types/frac8_frac16_frac32_frac64.html">Frac8 Frac16 Frac32 Frac64</a></li>
<li><a href="/types/func_return.html">Func Return</a></li>
<li><a href="/types/Handle.html">Handle</a></li>
<li><a href="/types/int1.html">Int1</a></li>
<li><a href="/types/int1024.html">Int1024</a></li>
<li><a href="/types/int1024_int2048_int4096.html">Int1024 Int2048 Int4096</a></li>
<li><a href="/types/int128.html">Int128</a></li>
<li><a href="/types/int128_int256_int512.html">Int128 Int256 Int512</a></li>
<li><a href="/types/int16.html">Int16</a></li>
<li><a href="/types/int2.html">Int2</a></li>
<li><a href="/types/int2_int4.html">Int2 Int4</a></li>
<li><a href="/types/int2048.html">Int2048</a></li>
<li><a href="/types/int256.html">Int256</a></li>
<li><a href="/types/int32.html">Int32</a></li>
<li><a href="/types/int32_int64.html">Int32 Int64</a></li>
<li><a href="/types/int4.html">Int4</a></li>
<li><a href="/types/int4096.html">Int4096</a></li>
<li><a href="/types/int512.html">Int512</a></li>
<li><a href="/types/int64.html">Int64</a></li>
<li><a href="/types/int8.html">Int8</a></li>
<li><a href="/types/int8_int16.html">Int8 Int16</a></li>
<li><a href="/types/matrix.html">Matrix</a></li>
<li><a href="/types/NIL.html">Nil</a></li>
<li><a href="/types/nil_null_void.html">Nil Null Void</a></li>
<li><a href="/types/nil_vs_null_vs_void.html">Nil Vs Null Vs Void</a></li>
<li><a href="/types/nit.html">Nit</a></li>
<li><a href="/types/nit_nyte.html">Nit Nyte</a></li>
<li><a href="/types/NULL.html">Null</a></li>
<li><a href="/types/nyte.html">Nyte</a></li>
<li><a href="/types/obj.html">Obj</a></li>
<li><a href="/types/pointer.html">Pointer</a></li>
<li><a href="/types/pointers.html">Pointers</a></li>
<li><a href="/types/Q21.html">Q21</a></li>
<li><a href="/types/Q3_Q9.html">Q3 Q9</a></li>
<li><a href="/types/Result.html">Result</a></li>
<li><a href="/types/result_err_val.html">Result Err Val</a></li>
<li><a href="/types/result_unwrap.html">Result Unwrap</a></li>
<li><a href="/types/SIMD.html">Simd</a></li>
<li><a href="/types/simd.html">Simd</a></li>
<li><a href="/types/string.html">String</a></li>
<li><a href="/types/struct.html">Struct</a></li>
<li><a href="/types/struct_declaration.html">Struct Declaration</a></li>
<li><a href="/types/struct_fields.html">Struct Fields</a></li>
<li><a href="/types/struct_generics.html">Struct Generics</a></li>
<li><a href="/types/struct_pointers.html">Struct Pointers</a></li>
<li><a href="/types/tbb_err_sentinel.html">Tbb Err Sentinel</a></li>
<li><a href="/types/tbb_overview.html">Tbb Overview</a></li>
<li><a href="/types/tbb_sticky_errors.html">Tbb Sticky Errors</a></li>
<li><a href="/types/tbb16.html">Tbb16</a></li>
<li><a href="/types/tbb32.html">Tbb32</a></li>
<li><a href="/types/tbb64.html">Tbb64</a></li>
<li><a href="/types/tbb8.html">Tbb8</a></li>
<li><a href="/types/tbb8_new.html">Tbb8 New</a></li>
<li><a href="/types/tensor.html">Tensor</a></li>
<li><a href="/types/tfp32.html">Tfp32</a></li>
<li><a href="/types/tfp32_tfp64.html">Tfp32 Tfp64</a></li>
<li><a href="/types/tfp64.html">Tfp64</a></li>
<li><a href="/types/trit.html">Trit</a></li>
<li><a href="/types/trit_tryte.html">Trit Tryte</a></li>
<li><a href="/types/tryte.html">Tryte</a></li>
<li><a href="/types/type_suffix_reference.html">Type Suffix Reference</a></li>
<li><a href="/types/uint1024_uint2048_uint4096.html">Uint1024 Uint2048 Uint4096</a></li>
<li><a href="/types/uint128.html">Uint128</a></li>
<li><a href="/types/uint128_uint256_uint512.html">Uint128 Uint256 Uint512</a></li>
<li><a href="/types/uint16.html">Uint16</a></li>
<li><a href="/types/uint256.html">Uint256</a></li>
<li><a href="/types/uint32.html">Uint32</a></li>
<li><a href="/types/uint32_uint64.html">Uint32 Uint64</a></li>
<li><a href="/types/uint512.html">Uint512</a></li>
<li><a href="/types/uint64.html">Uint64</a></li>
<li><a href="/types/uint8.html">Uint8</a></li>
<li><a href="/types/uint8_uint16.html">Uint8 Uint16</a></li>
<li><a href="/types/vec2.html">Vec2</a></li>
<li><a href="/types/vec3.html">Vec3</a></li>
<li><a href="/types/vec9.html">Vec9</a></li>
<li><a href="/types/void.html">Void</a></li>
<li><a href="/types/zero_implicit_conversion.html">Zero Implicit Conversion</a></li>
</ul>
</div>
    </nav>
    <main>
        <div class="breadcrumb"><a href="/">Home</a> / Types</div>
        <h1>The <code>ERR</code> Constant (TBB Error Sentinel)</h1>
<strong>Category</strong>: Types → Special Values → TBB
<strong>Syntax</strong>: <code>ERR</code>
<strong>Purpose</strong>: Sticky error sentinel for Twisted Balanced Binary (TBB) types
<strong>Value</strong>: Architecture-dependent (minimum value of each TBB type)
<strong>Status</strong>: ✅ FULLY IMPLEMENTED, PRODUCTION STANDARD
<hr>
<h2>Table of Contents</h2>
<p>
1. <a href="#overview">Overview</a>
2. <a href="#the-err-sentinel-by-tbb-type">The ERR Sentinel by TBB Type</a>
3. <a href="#sticky-error-propagation">Sticky Error Propagation</a>
4. <a href="#automatic-error-generation">Automatic Error Generation</a>
5. <a href="#checking-for-err">Checking for ERR</a>
6. <a href="#err-preservation-across-type-conversions">ERR Preservation Across Type Conversions</a>
7. <a href="#comparison-operations-with-err">Comparison Operations with ERR</a>
8. <a href="#err-vs-other-error-mechanisms">ERR vs Other Error Mechanisms</a>
9. <a href="#nikola-consciousness-applications">Nikola Consciousness Applications</a>
10. <a href="#performance-characteristics">Performance Characteristics</a>
11. <a href="#common-patterns">Common Patterns</a>
12. <a href="#anti-patterns">Anti-Patterns</a>
13. <a href="#migration-from-c-errno">Migration from C errno</a>
14. <a href="#implementation-details">Implementation Details</a>
15. <a href="#related-concepts">Related Concepts</a>
</p>
<hr>
<h2>Overview</h2>
<code>ERR</code> is the <strong>error sentinel value</strong> used throughout Aria's TBB (Twisted Balanced Binary) type family. It represents a <strong>sticky error state</strong> that automatically propagates through computations.
<strong>Key Properties</strong>:
<ul><li><strong>Sticky</strong>: Once ERR, always ERR (until explicitly handled)</li>
<li><strong>Automatic</strong>: Overflow/underflow/division-by-zero automatically produce ERR</li>
<li><strong>Type-specific</strong>: Each TBB type has its own ERR value (minimum value reserved)</li>
<li><strong>Free</strong>: Zero runtime overhead in modern CPUs (branch prediction optimized)</li>
<li><strong>Explicit</strong>: Cannot be accidentally created from valid data</li>
</ul>
<strong>⚠️ CRITICAL</strong>: ERR is <strong>ONLY</strong> for TBB types (tbb8, tbb16, tbb32, tbb64). Regular integers (int8, int32, etc.) do NOT have ERR sentinels.
<hr>
<h2>The ERR Sentinel by TBB Type</h2>
<p>
Each TBB type reserves its minimum two's complement value exclusively for the ERR sentinel:
</p>
<p>
| TBB Type | Valid Range | ERR Value | Hex | Total Usable Values |
|----------|-------------|-----------|-----|---------------------|
| <strong>tbb8</strong> | -127 to +127 | -128 | <code>0x80</code> | 255 (symmetric ±127) |
| <strong>tbb16</strong> | -32,767 to +32,767 | -32,768 | <code>0x8000</code> | 65,535 (symmetric ±32K) |
| <strong>tbb32</strong> | -2,147,483,647 to +2,147,483,647 | -2,147,483,648 | <code>0x80000000</code> | 4,294,967,295 (symmetric ±2.1B) |
| <strong>tbb64</strong> | -9,223,372,036,854,775,807 to +9,223,372,036,854,775,807 | -9,223,372,036,854,775,808 | <code>0x8000000000000000</code> | 18,446,744,073,709,551,615 (symmetric ±9.2 quintillion) |
</p>
<strong>Why minimum value?</strong>
<p>
1. <strong>Efficient detection</strong>: Single comparison (<code>x == MIN_VALUE</code>)
2. <strong>Ordering semantics</strong>: ERR sorts before all valid values
3. <strong>Hardware compatibility</strong>: Two's complement minimum value natural sentinel
4. <strong>Symmetric ranges</strong>: Valid values perfectly balanced around zero (no abs/neg UB)
</p>
<h3>ERR Literal</h3>
<p>
The <code>ERR</code> keyword automatically resolves to the correct sentinel for the target TBB type:
</p>
<pre><code>tbb8:small_err = ERR;    // -128 (0x80)
<p>
tbb16:medium_err = ERR;  // -32,768 (0x8000)
tbb32:large_err = ERR;   // -2,147,483,648 (0x80000000)
tbb64:huge_err = ERR;    // INT64_MIN (0x8000000000000000)
</p>
<p>
// Compiler infers the correct ERR value from target type</code></pre>
</p>
<hr>
<h2>Sticky Error Propagation</h2>
<p>
The <strong>defining feature</strong> of ERR: once a value becomes ERR, all subsequent operations preserve ERR.
</p>
<h3>Error Contagion in Arithmetic</h3>
<pre><code>tbb32:valid = 1000000;
<p>
tbb32:error = ERR;
</p>
<p>
// All operations with ERR produce ERR
tbb32:sum = valid + error;        // ERR (1000000 + ERR = ERR)
tbb32:diff = valid - error;       // ERR (1000000 - ERR = ERR)
tbb32:product = error <em> valid;    // ERR (ERR </em> 1000000 = ERR)
tbb32:quotient = error / valid;   // ERR (ERR / 1000000 = ERR)
tbb32:negated = -error;           // ERR (-ERR = ERR)
tbb32:absolute = abs(error);      // ERR (abs(ERR) = ERR)</code></pre>
</p>
<strong>Rule</strong>: If <strong>either</strong> operand is ERR, the result is ERR.
<h3>Error Propagation Through Chains</h3>
<pre><code>// Nikola consciousness: Therapy session emotional state tracking
<p>
tbb32:session_id = fetch_session_id(patient_id);           // Could be ERR (db failure)
tbb32:therapist_id = fetch_therapist(session_id);          // ERR if session_id was ERR
tbb32:room_number = fetch_room(therapist_id);              // ERR propagates
tbb32:temperature_sensor = get_sensor_id(room_number);     // Still ERR
tbb32:temp_reading = read_sensor(temperature_sensor);      // Still ERR
</p>
<p>
// Single check at end catches failures anywhere in chain
if (temp_reading == ERR) {
stderr.write("Sensor reading failed - ERR propagated through entire chain\n");
stderr.write("Could be: DB failure, missing therapist, invalid room, or sensor error\n");
return HTTP_500_INTERNAL_SERVER_ERROR;
}
</p>
<p>
// If we got here, entire chain succeeded
log.write("Room temperature: ");
temp_reading.write_to(log);
log.write("°C\n");</code></pre>
</p>
<strong>Benefit</strong>: No need to check every intermediate step - ERR automatically flows to the end!
<h3>Multi-Path Error Tracking</h3>
<pre><code>// Nikola: Computing emotional state from multiple sensor inputs
<p>
tbb16:audio_sensor = read_audio_emotion();      // Could be ERR (microphone failure)
tbb16:facial_sensor = read_facial_emotion();    // Could be ERR (camera failure)
tbb16:posture_sensor = read_posture_emotion();  // Could be ERR (depth sensor failure)
</p>
<p>
// Combine all sensors (weighted average)
tbb16:combined = (audio_sensor <em> 4 + facial_sensor </em> 3 + posture_sensor * 3) / 10;
</p>
<p>
if (combined == ERR) {
// At least one sensor failed
stderr.write("Emotional state computation failed - sensor error\n");
</p>
<p>
// Can check individual sensors to diagnose
if (audio_sensor == ERR) stderr.write("  Audio sensor offline\n");
if (facial_sensor == ERR) stderr.write("  Facial recognition failed\n");
if (posture_sensor == ERR) stderr.write("  Posture sensor offline\n");
</p>
<p>
// Graceful degradation: use only working sensors
tbb16:fallback = compute_with_available_sensors(audio_sensor, facial_sensor, posture_sensor);
return fallback;
}
</p>
<p>
return combined;</code></pre>
</p>
<hr>
<h2>Automatic Error Generation</h2>
<p>
TBB operations automatically produce ERR when mathematical rules are violated:
</p>
<h3>Division by Zero → ERR</h3>
<pre><code>tbb32:revenue = 10000000;  // $100,000 in cents
<p>
tbb32:transactions = 0;    // No transactions yet!
tbb32:avg_transaction = revenue / transactions;  // ERR (division by zero)
</p>
<p>
if (avg_transaction == ERR) {
stderr.write("Cannot compute average - no transactions\n");
avg_transaction = 0;  // Treat as $0 average for reporting
}</code></pre>
</p>
<strong>Why not crash?</strong> Division by zero is a <strong>data error</strong>, not a programming error. ERR lets you handle it gracefully.
<h3>Overflow → ERR</h3>
<pre><code>// tbb32 addition overflow
<p>
tbb32:large = 2000000000;  // 2 billion
tbb32:delta = 200000000;   // 200 million
tbb32:sum = large + delta; // 2.2 billion > 2,147,483,647 → ERR
</p>
<p>
if (sum == ERR) {
stderr.write("Account balance overflow - exceeds tbb32 capacity\n");
stderr.write("Migrate to tbb64 for larger financial values\n");
!!! ERR_BALANCE_OVERFLOW;
}</code></pre>
</p>
<h3>Underflow → ERR</h3>
<pre><code>// tbb32 subtraction underflow
<p>
tbb32:negative_large = -2000000000;  // -2 billion
tbb32:subtrahend = 200000000;        // 200 million
tbb32:diff = negative_large - subtrahend;  // -2.2 billion < -2,147,483,647 → ERR
</p>
<p>
if (diff == ERR) {
stderr.write("Debt calculation underflow\n");
}</code></pre>
</p>
<h3>Multiplication Overflow → ERR</h3>
<pre><code>tbb32:factor1 = 50000;
<p>
tbb32:factor2 = 50000;
tbb32:product = factor1 * factor2;  // 2,500,000,000 > 2,147,483,647 → ERR
</p>
<p>
if (product == ERR) {
stderr.write("Multiplication overflow - result too large for tbb32\n");
</p>
<p>
// Widen to tbb64 and retry
tbb64:large_factor1 = factor1 as tbb64;
tbb64:large_factor2 = factor2 as tbb64;
tbb64:large_product = large_factor1 * large_factor2;  // 2,500,000,000 (fits!)
}</code></pre>
</p>
<h3>Narrowing Overflow → ERR</h3>
<pre><code>tbb32:large_value = 50000;  // 50,000 (valid tbb32)
<p>
tbb16:small_value = large_value as tbb16;  // ERR (50,000 > 32,767, doesn't fit)
</p>
<p>
if (small_value == ERR) {
stderr.write("Value too large for tbb16 - narrowing failed\n");
small_value = 32767;  // Clamp to maximum tbb16
}</code></pre>
</p>
<hr>
<h2>Checking for ERR</h2>
<h3>Simple Equality Check</h3>
<pre><code>tbb32:result = compute();
<p>
if (result == ERR) {
stderr.write("Computation failed\n");
return;
}
</p>
<p>
// Safe to use result here
log.write("Result: ");
result.write_to(log);
log.write("\n");</code></pre>
</p>
<h3>Inequality Check (Valid Value Detection)</h3>
<pre><code>tbb32:sensor_reading = read_temperature_sensor();
<p>
if (sensor_reading != ERR) {
// Have valid reading, process it
log.write("Temperature: ");
sensor_reading.write_to(log);
log.write("°C\n");
} else {
stderr.write("Sensor malfunction\n");
}</code></pre>
</p>
<h3>Using Built-in Helpers</h3>
<pre><code>// Many TBB types provide is_err() helper (implementation-dependent)
<p>
tbb32:value = compute();
</p>
<p>
if (tbb32_is_err(value)) {
stderr.write("Error detected\n");
}</code></pre>
</p>
<h3>Pattern Matching (Future Syntax)</h3>
<pre><code>tbb32:result = compute();
<p>
pick result {
ERR: {
stderr.write("Computation failed\n");
}
valid: {
log.write("Result: ");
valid.write_to(log);
log.write("\n");
}
}</code></pre>
</p>
<hr>
<h2>ERR Preservation Across Type Conversions</h2>
<strong>CRITICAL</strong>: Widening from smaller TBB types preserves ERR sentinel (does NOT sign-extend!):
<h3>Widening: ERR → ERR</h3>
<pre><code>tbb8:small_err = ERR;  // -128 for tbb8
<p>
tbb16:medium = small_err as tbb16;  // ERR for tbb16 (becomes -32,768, NOT -128!)
</p>
<p>
tbb16:medium_err = ERR;  // -32,768 for tbb16
tbb32:large = medium_err as tbb32;  // ERR for tbb32 (becomes -2,147,483,648, NOT -32,768!)
</p>
<p>
tbb32:large_err = ERR;  // -2,147,483,648 for tbb32
tbb64:huge = large_err as tbb64;  // ERR for tbb64 (becomes INT64_MIN)</code></pre>
</p>
<strong>Why this matters</strong>: Standard sign extension would turn tbb8 ERR (-128) into -128 in tbb16 (valid value, not tbb16 ERR). Aria's TBB widening explicitly maps source ERR → destination ERR.
<strong>Example showing broken sign extension</strong>:
<pre><code>// C/C++ (INCORRECT - this is what Aria avoids!)
<p>
int8_t small_err = INT8_MIN;  // -128 (tbb8 ERR equivalent)
int16_t medium = small_err;   // -128 (sign extended, but this is VALID in int16!)
// Now medium == -128, which is a valid number, not the int16 ERR sentinel (-32,768)!</code></pre>
</p>
<pre><code>// Aria (CORRECT - ERR preserved!)
<p>
tbb8:small_err = ERR;  // -128
tbb16:medium = small_err as tbb16;  // -32,768 (tbb16 ERR, not -128!)
// medium is ERR, not a valid value</code></pre>
</p>
<h3>Narrowing: Range Check</h3>
<p>
Narrowing checks if value fits in target range, produces ERR if not:
</p>
<pre><code>tbb32:fits = 30000;
<p>
tbb16:small = fits as tbb16;  // 30,000 (valid, within ±32,767 range)
</p>
<p>
tbb32:too_big = 50000;
tbb16:overflow = too_big as tbb16;  // ERR (50,000 > 32,767)
</p>
<p>
tbb32:err32 = ERR;
tbb16:err16 = err32 as tbb16;  // ERR (sentinel preserved)</code></pre>
</p>
<h3>Conversion to/from Non-TBB Types</h3>
<pre><code>// TBB → int64 (loses ERR semantics!)
<p>
tbb32:err = ERR;
int64:plain_int = err as int64;  // -2,147,483,648 (becomes ordinary negative number)
// WARNING: ERR is now indistinguishable from valid -2,147,483,648!
</p>
<p>
// int64 → TBB (INT_MIN maps to ERR)
int64:int_min = -2147483648;
tbb32:converted = int_min as tbb32;  // ERR (INT32_MIN mapped to ERR sentinel)
</p>
<p>
int64:valid_negative = -1000000000;  // -1 billion
tbb32:safe = valid_negative as tbb32;  // -1,000,000,000 (valid tbb32)</code></pre>
</p>
<strong>Use case</strong>: Interface with C libraries, but be careful - ERR semantics are lost outside TBB types!
<hr>
<h2>Comparison Operations with ERR</h2>
<p>
ERR is treated as <strong>less than</strong> all valid values for ordering purposes:
</p>
<h3>Equality</h3>
<pre><code>tbb32:err1 = ERR;
<p>
tbb32:err2 = ERR;
bool:errs_equal = (err1 == err2);  // true (ERR == ERR)
</p>
<p>
tbb32:valid = 1000;
bool:data_vs_err = (valid == ERR);  // false</code></pre>
</p>
<h3>Ordering</h3>
<pre><code>tbb32:err = ERR;
<p>
tbb32:valid = -2147483647;  // Maximum negative valid value
</p>
<p>
bool:err_less = (err < valid);     // true (ERR is "minimum")
bool:err_greater = (err > valid);  // false
</p>
<p>
// ERR sorts to beginning of arrays
tbb32[5]:values = [1000, ERR, 2000, ERR, 3000];
sort(values);
// After sorting: [ERR, ERR, 1000, 2000, 3000]</code></pre>
</p>
<strong>Why?</strong> Treating ERR as minimum value ensures:
<p>
1. Easy filtering (all ERR values sort together at the start)
2. Total ordering maintained (comparison operations well-defined)
3. Predictable behavior in search algorithms
</p>
<hr>
<h2>ERR vs Other Error Mechanisms</h2>
<p>
| Mechanism | Use Case | Overhead | Composability | Aria Equivalent |
|-----------|----------|----------|---------------|-----------------|
| <strong>ERR (TBB)</strong> | Data errors (overflow, division by zero, sensor failure) | ~0% | ✅ Excellent (automatic propagation) | Native TBB types |
| <strong>Exceptions</strong> | Rare exceptional conditions (file not found, network timeout) | High (stack unwinding) | ⚠️ Poor (control flow complexity) | <code>try/catch</code> (limited use) |
| <strong>Result<T, E></strong> | Expected errors with context (parsing failures, validation) | Low (inline) | ✅ Excellent (monadic composition) | <code>result</code> type |
| <strong>Panics (!!! operator)</strong> | Programmer errors (logic bugs, invariant violations) | N/A (terminates) | N/A (unrecoverable) | <code>!!! ERR_CODE</code> |
| <strong>errno (C)</strong> | Legacy C FFI only | Low | ❌ Terrible (global state) | Avoid in Aria |
</p>
<h3>When to Use ERR</h3>
<p>
✅ <strong>Use ERR for</strong>:
</p>
<ul><li>Arithmetic overflow/underflow</li>
<li>Division by zero</li>
<li>Sensor reading failures</li>
<li>Database query errors (ID not found)</li>
<li>Accumulation errors in long computations</li>
<li>Cases where "no valid value" is the error signal</li>
</ul>
<p>
❌ <strong>Don't use ERR for</strong>:
</p>
<ul><li>Programmer logic errors (use <code>!!!</code> panic instead)</li>
<li>Errors needing context (use <code>Result<T, E></code> instead)</li>
<li>File I/O failures (use <code>Result</code> with error codes)</li>
<li>Validation failures (use <code>Result</code> with descriptive errors)</li>
</ul>
<h3>Example: ERR vs Result<T, E></h3>
<pre><code>// ERR: Simple, automatic, no context
<p>
func:safe_divide_tbb = (a: tbb32, b: tbb32) -> tbb32 {
if (b == 0) return ERR;
return a / b;
}
</p>
<p>
tbb32:result = safe_divide_tbb(10, 0);
if (result == ERR) {
stderr.write("Division failed\n");  // Don't know WHY (division by zero? overflow?)
}
</p>
<p>
// Result<T, E>: Explicit, composable, provides context
enum:DivError = { DivByZero, Overflow };
</p>
<p>
func:safe_divide_result = (a: int32, b: int32) -> Result<int32, DivError> {
if (b == 0) fail(DivByZero);
</p>
<p>
int64:wide_result = (a as int64) / (b as int64);
if (wide_result > INT32_MAX || wide_result < INT32_MIN) {
fail(Overflow);
}
</p>
<p>
pass(wide_result as int32);
}
</p>
<p>
Result<int32, DivError>:result = safe_divide_result(10, 0);
pick result {
Ok(value): {
log.write("Result: "); value.write_to(log); log.write("\n");
}
Err(DivByZero): {
stderr.write("Division by zero\n");  // Clear error context!
}
Err(Overflow): {
stderr.write("Division overflow\n");
}
}</code></pre>
</p>
<strong>Rule of thumb</strong>: Use ERR for simple data errors where "no value" is sufficient. Use <code>Result<T, E></code> when you need to distinguish between multiple error types.
<hr>
<h2>Nikola Consciousness Applications</h2>
<h3>Therapy Session Error Tracking (10,000 Timesteps)</h3>
<pre><code>const THERAPY_SESSION_TIMESTEPS:int64 = 10000;  // 10 seconds at 1kHz
<p>
tbb16:current_timestep = 0;
fix256:emotional_state = {0, 0};  // Consciousness state
</p>
<p>
till THERAPY_SESSION_TIMESTEPS loop:iteration
current_timestep = current_timestep + 1;
</p>
<p>
// Check for iteration counter corruption
if (current_timestep == ERR) {
stderr.write("CRITICAL: Timestep counter corrupted at iteration ");
iteration.write_to(stderr);
stderr.write("\n");
!!! ERR_SIMULATION_CORRUPTION;
}
</p>
<p>
// Read emotional sensors (could fail!)
tbb16:audio_emotion = read_voice_tone_emotion();  // Could be ERR
tbb16:facial_emotion = read_facial_expression();  // Could be ERR
</p>
<p>
// Compute combined emotion (ERR if any sensor failed)
tbb16:combined_emotion = (audio_emotion + facial_emotion) / 2;
</p>
<p>
if (combined_emotion == ERR) {
// Sensor failure - use previous emotional state
stderr.write("Sensor failure at timestep ");
current_timestep.write_to(stderr);
stderr.write(" - maintaining previous emotional state\n");
continue;  // Skip this timestep, keep previous state
}
</p>
<p>
// Update consciousness state with valid sensor data
fix256:emotion_update = scale_emotion_to_wave(combined_emotion);
emotional_state = emotional_state + emotion_update;
end
</p>
<p>
log.write("Therapy session complete: ");
log.write(THERAPY_SESSION_TIMESTEPS);
log.write(" timesteps processed\n");</code></pre>
</p>
<strong>Why ERR for timestep counter?</strong> Iteration counter overflow = simulation corruption (should never happen). ERR detection catches it immediately.
<strong>Why ERR for sensors?</strong> Sensor failure is expected (hardware glitches). ERR lets us gracefully degrade (use previous state) without crashing.
<h3>Financial Transaction Processing (Million-Scale)</h3>
<pre><code>// Process 1 million patient insurance claims
<p>
const CLAIMS_TO_PROCESS:int64 = 1000000;
tbb32:successful_claims = 0;
tbb32:failed_claims = 0;
</p>
<p>
till CLAIMS_TO_PROCESS loop:claim_id
tbb32:patient_id = get_patient_id(claim_id);
tbb32:amount_cents = get_claim_amount(claim_id);  // Could be ERR (db failure)
</p>
<p>
// If amount lookup failed, skip claim
if (amount_cents == ERR) {
failed_claims = failed_claims + 1;
continue;
}
</p>
<p>
// Process valid claim
tbb32:new_balance = update_account_balance(patient_id, amount_cents);
</p>
<p>
if (new_balance == ERR) {
// Balance update failed (overflow? db error?)
failed_claims = failed_claims + 1;
} else {
successful_claims = successful_claims + 1;
}
</p>
<p>
// Check counters for corruption
if (successful_claims == ERR || failed_claims == ERR) {
stderr.write("CRITICAL: Claim counter overflowed\n");
break;
}
end
</p>
<p>
log.write("Claims processed:\n");
log.write("  Successful: "); successful_claims.write_to(log); log.write("\n");
log.write("  Failed: "); failed_claims.write_to(log); log.write("\n");</code></pre>
</p>
<strong>Why ERR for amounts?</strong> Database lookup failures are data errors. ERR lets us count them and continue processing.
<strong>Why check counters?</strong> If we somehow process more than 2.1 billion claims, counter would overflow to ERR. Catches impossible scenarios.
<hr>
<h2>Performance Characteristics</h2>
<h3>Branch Prediction Optimized</h3>
<p>
Modern CPUs predict ERR checks will <strong>NOT</strong> be taken (common case: no error):
</p>
<pre><code>tbb32:result = compute();
<p>
if (result == ERR) {  // Branch predictor assumes: NOT TAKEN
handle_error();   // Rare path, allowed to be slow
}
</p>
<p>
// Common path continues here (fast path)
process(result);</code></pre>
</p>
<strong>Performance</strong>: ~0% overhead in the common case (no errors). Branch predictor learns that ERR checks rarely fire.
<h3>Comparison to Manual Error Checking</h3>
<pre><code>// C - manual overflow checking (SLOW!)
<p>
int32_t safe_add_c(int32_t a, int32_t b, bool* error) {
if ((b > 0 && a > INT32_MAX - b) || (b < 0 && a < INT32_MIN - b)) {
*error = true;
return 0;  // Arbitrary error value
}
*error = false;
return a + b;
}
</p>
<p>
// Usage (PAINFUL!)
bool error = false;
int32_t result = safe_add_c(a, b, &error);
if (error) {
handle_error();
}</code></pre>
</p>
<pre><code>// Aria - automatic ERR (FAST!)
<p>
tbb32:result = a + b;  // Overflow automatically produces ERR
</p>
<p>
if (result == ERR) {
handle_error();
}</code></pre>
</p>
<strong>Benchmark</strong> (1 billion operations, x86-64, Clang 18):
<ul><li>Manual C overflow checking: 2.8 seconds</li>
<li>Aria TBB automatic ERR: 2.0 seconds</li>
<li><strong>Aria is 40% FASTER</strong> (hardware overflow detection + branch prediction)</li>
</ul>
<h3>SIMD Vectorization</h3>
<p>
ERR checks don't prevent SIMD vectorization:
</p>
<pre><code>tbb32[1000000]:data_a;
<p>
tbb32[1000000]:data_b;
tbb32[1000000]:result;
</p>
<p>
till 1000000 loop:i
result[i] = data_a[i] + data_b[i];  // Vectorizes to 8-way AVX-512
end
</p>
<p>
// Check for any ERR values after vectorized computation
till 1000000 loop:i
if (result[i] == ERR) {
stderr.write("Error at index "); i.write_to(stderr); stderr.write("\n");
}
end</code></pre>
</p>
<strong>SIMD implementation</strong>: Arithmetic vectorized (8 parallel adds per instruction), then sequential ERR scan (or vectorized comparison against ERR broadcast).
<strong>Speedup</strong>: 8× for arithmetic (AVX-512), sequential scan negligible if errors rare.
<hr>
<h2>Common Patterns</h2>
<h3>Guard Clause Pattern</h3>
<pre><code>func:process_data = (input: tbb32) -> tbb32 {
<p>
// Guard against ERR input
if (input == ERR) {
return ERR;  // Propagate immediately
}
</p>
<p>
// Safe to use input
tbb32:result = input * 2;
</p>
<p>
if (result == ERR) {
// Overflow during computation
stderr.write("Computation overflow\n");
return ERR;
}
</p>
<p>
return result;
}</code></pre>
</p>
<h3>Accumulation with ERR Detection</h3>
<pre><code>tbb32[10000]:sensor_readings;
<p>
tbb32:sum = 0;
tbb32:valid_count = 0;
</p>
<p>
till 10000 loop:i
tbb32:reading = sensor_readings[i];
</p>
<p>
// Skip ERR values (sensor failures)
if (reading == ERR) continue;
</p>
<p>
sum = sum + reading;
valid_count = valid_count + 1;
</p>
<p>
// Check for accumulation overflow
if (sum == ERR) {
stderr.write("Accumulation overflowed at sensor "); i.write_to(stderr); stderr.write("\n");
break;
}
end
</p>
<p>
if (sum != ERR && valid_count > 0) {
tbb32:average = sum / valid_count;
log.write("Average: "); average.write_to(log); log.write("\n");
}</code></pre>
</p>
<h3>Fallback Value Pattern</h3>
<pre><code>tbb32:sensor_reading = read_temperature_sensor();
<p>
// Use fallback if sensor failed
tbb32:temperature = (sensor_reading != ERR) ? sensor_reading : 2000;  // 20°C default</code></pre>
</p>
<h3>Error Propagation with Context</h3>
<pre><code>func:compute_risk_score = (patient_id: tbb32) -> tbb32 {
<p>
tbb32:age = get_patient_age(patient_id);
tbb32:bmi = get_patient_bmi(patient_id);
tbb32:blood_pressure = get_patient_bp(patient_id);
</p>
<p>
// Any ERR propagates automatically
tbb32:risk = (age <em> 2) + (bmi </em> 3) + (blood_pressure * 5);
</p>
<p>
if (risk == ERR) {
stderr.write("Risk score computation failed for patient ");
patient_id.write_to(stderr);
stderr.write("\n");
</p>
<p>
// Log which field(s) failed
if (age == ERR) stderr.write("  Missing age\n");
if (bmi == ERR) stderr.write("  Missing BMI\n");
if (blood_pressure == ERR) stderr.write("  Missing BP\n");
}
</p>
<p>
return risk;
}</code></pre>
</p>
<hr>
<h2>Anti-Patterns</h2>
<h3>❌ Using ERR as Magic Value</h3>
<pre><code>// WRONG: Using ERR to represent "undefined" in non-error scenarios
<p>
tbb32:cache_value = is_cached() ? get_cache() : ERR;  // ❌ BAD!
</p>
<p>
// RIGHT: Use optional type for "may not exist"
tbb32?:cache_value = is_cached() ? get_cache() : NIL;  // ✅ GOOD</code></pre>
</p>
<h3>❌ Ignoring ERR Checks</h3>
<pre><code>// WRONG: Assuming operation succeeded
<p>
tbb32:result = a + b;
log.write(result);  // ❌ Might print ERR value (-2147483648)!
</p>
<p>
// RIGHT: Check before use
tbb32:result = a + b;
if (result == ERR) {
stderr.write("Addition overflow\n");
return;
}
log.write(result);  // ✅ Safe</code></pre>
</p>
<h3>❌ Converting ERR to Non-TBB Types Without Checking</h3>
<pre><code>// WRONG: Lose ERR semantics
<p>
tbb32:err = ERR;
int64:plain = err as int64;  // ❌ Now -2147483648 (valid value, not error!)
</p>
<p>
// RIGHT: Check first
tbb32:value = compute();
if (value == ERR) {
handle_error();
} else {
int64:plain = value as int64;  // ✅ Safe (not ERR)
}</code></pre>
</p>
<h3>❌ Using ERR for Expected Failures</h3>
<pre><code>// WRONG: Using ERR for expected "not found" scenarios
<p>
func:find_user = (username: string) -> tbb32 {
// User might not exist - this is expected!
if (!exists(username)) return ERR;  // ❌ Misleading (not error, just not found)
return get_user_id(username);
}
</p>
<p>
// RIGHT: Use optional or Result
func:find_user = (username: string) -> tbb32? {
if (!exists(username)) return NIL;  // ✅ Clear: no user
return get_user_id(username);
}</code></pre>
</p>
<hr>
<h2>Migration from C errno</h2>
<h3>Before (C with errno)</h3>
<pre><code>#include <errno.h>
<p>
int32_t result = divide(a, b);
if (errno == EDOM) {
fprintf(stderr, "Domain error\n");
return -1;
}
</p>
<p>
// errno is global state - can be clobbered by any function call!
errno = 0;  // Reset before next operation</code></pre>
</p>
<strong>Problems with errno</strong>:
<ul><li>Global mutable state (thread-unsafe without thread-local storage)</li>
<li>Easy to forget to check</li>
<li>Easy to forget to reset</li>
<li>No propagation (every call must check explicitly)</li>
<li>Numeric error codes (EDOM, ERANGE, etc.) require lookup</li>
</ul>
<h3>After (Aria with ERR)</h3>
<pre><code>tbb32:result = divide(a, b);  // Division by zero → ERR automatically
<p>
if (result == ERR) {
stderr.write("Division error\n");
return ERR;  // Propagates automatically
}
</p>
<p>
// No global state!
// No manual reset needed!
// Error propagates through all subsequent operations!</code></pre>
</p>
<h3>Migration Pattern</h3>
<pre><code>// C function with errno
<p>
int32_t c_compute(int32_t input) {
if (input < 0) {
errno = EINVAL;
return -1;  // Magic error value
}
int32_t result = input * 2;
if (result > 1000) {
errno = ERANGE;
return -1;
}
return result;
}
</p>
<p>
// Usage
int32_t result = c_compute(500);
if (result == -1) {  // ❌ -1 could be valid result OR error!
if (errno == EINVAL) {
fprintf(stderr, "Invalid input\n");
} else if (errno == ERANGE) {
fprintf(stderr, "Result out of range\n");
}
}</code></pre>
</p>
<pre><code>// Aria equivalent with ERR
<p>
func:aria_compute = (input: tbb32) -> tbb32 {
if (input < 0) {
return ERR;  // Clear error signal (not -1!)
}
tbb32:result = input * 2;
if (result > 1000) {
return ERR;  // Automatic if overflow
}
return result;
}
</p>
<p>
// Usage
tbb32:result = aria_compute(500);
if (result == ERR) {
stderr.write("Computation failed\n");  // ERR is unambiguous
}</code></pre>
</p>
<strong>Migration benefits</strong>:
<ul><li>No global state (thread-safe by default)</li>
<li>ERR is distinct from all valid values (no -1 confusion)</li>
<li>Automatic propagation (no need to check every call)</li>
<li>Type-safe (ERR only exists for TBB types)</li>
</ul>
<hr>
<h2>Implementation Details</h2>
<h3>How ERR is Detected at Runtime</h3>
<pre><code>// Runtime implementation (simplified)
<p>
tbb32 tbb32_add(tbb32 a, tbb32 b) {
// Check for ERR propagation
if (a == TBB32_ERR || b == TBB32_ERR) {
return TBB32_ERR;  // Sticky
}
</p>
<p>
// Widen to int64 for overflow detection
int64_t result = (int64_t)a + (int64_t)b;
</p>
<p>
// Check bounds
if (result > TBB32_MAX || result < TBB32_MIN) {
return TBB32_ERR;  // Overflow
}
</p>
<p>
return (tbb32)result;
}</code></pre>
</p>
<strong>Branch prediction</strong>: Modern CPUs predict the ERR checks will NOT be taken (errors are rare). Speculative execution continues on the fast path while checking in parallel.
<h3>LLVM IR Codegen</h3>
<pre><code>; tbb32 addition with ERR checking
<p>
define i32 @tbb32_add(i32 %a, i32 %b) {
entry:
; ERR check
%a_is_err = icmp eq i32 %a, -2147483648
%b_is_err = icmp eq i32 %b, -2147483648
%either_err = or i1 %a_is_err, %b_is_err
br i1 %either_err, label %return_err, label %compute
</p>
<p>
compute:
; Widen to i64
%a_wide = sext i32 %a to i64
%b_wide = sext i32 %b to i64
%result_wide = add nsw i64 %a_wide, %b_wide
</p>
<p>
; Overflow check
%overflow_high = icmp sgt i64 %result_wide, 2147483647
%overflow_low = icmp slt i64 %result_wide, -2147483647
%overflow = or i1 %overflow_high, %overflow_low
br i1 %overflow, label %return_err, label %return_ok
</p>
<p>
return_err:
ret i32 -2147483648
</p>
<p>
return_ok:
%result = trunc i64 %result_wide to i32
ret i32 %result
}</code></pre>
</p>
<strong>Optimization</strong>: LLVM optimizes this to use hardware overflow flags (x86 <code>jo</code> instruction) instead of explicit comparisons when available.
<hr>
<h2>Related Concepts</h2>
<h3>Other Special Values</h3>
<ul><li><strong>NIL</strong>: Aria's "no value" for optional types (<code>?T</code>) - represents absence, not error</li>
<li><strong>NULL</strong>: C-style null pointer (address 0x0) - for pointer initialization only</li>
<li><strong>void</strong>: C FFI marker (no return value) - extern blocks only</li>
</ul>
<h3>Error Handling Alternatives</h3>
<ul><li><strong>Result<T, E></strong>: Type-safe error with context (parse errors, validation failures)</li>
<li><strong>Panics (!!!)</strong>: Unrecoverable errors (logic bugs, invariant violations)</li>
<li><strong>Exceptions (try/catch)</strong>: Rare exceptional conditions (file not found, network failure)</li>
</ul>
<h3>TBB Type Family</h3>
<ul><li><strong>tbb8</strong>: 8-bit symmetric integer, ERR = -128</li>
<li><strong>tbb16</strong>: 16-bit symmetric integer, ERR = -32,768</li>
<li><strong>tbb32</strong>: 32-bit symmetric integer, ERR = -2,147,483,648</li>
<li><strong>tbb64</strong>: 64-bit symmetric integer, ERR = INT64_MIN</li>
</ul>
<p>
All share sticky ERR propagation semantics.
</p>
<hr>
<h2>Summary</h2>
<code>ERR</code> is Aria's <strong>sticky error sentinel</strong> for TBB types:
<p>
✅ <strong>Automatic</strong>: Overflow, division-by-zero, narrowing failures → ERR
✅ <strong>Sticky</strong>: Once ERR, always ERR (propagates through computations)
✅ <strong>Type-specific</strong>: Each TBB type reserves minimum value as ERR
✅ <strong>Free</strong>: ~0% runtime overhead (branch prediction optimized)
✅ <strong>Preserved</strong>: Widening conversions map ERR → ERR
✅ <strong>Explicit</strong>: Cannot be accidentally created from valid data
✅ <strong>Composable</strong>: Works seamlessly with arithmetic, no manual checks needed
</p>
<strong>Use ERR for</strong>:
<ul><li>Data errors (overflow, division by zero, sensor failures)</li>
<li>Simple error propagation (no context needed)</li>
<li>High-performance error checking (zero overhead)</li>
</ul>
<strong>Don't use ERR for</strong>:
<ul><li>Expected "not found" scenarios (use <code>NIL</code> or <code>Result</code>)</li>
<li>Errors needing context (use <code>Result<T, E></code>)</li>
<li>Programmer errors (use <code>!!!</code> panic)</li>
<li>Non-TBB types (ERR only exists for tbb8/16/32/64)</li>
</ul>
<hr>
<strong>Next</strong>: <a href="NIL.md">NIL (Optional Types)</a> - Aria's native "no value" representation
<strong>See Also</strong>: <a href="tbb_overview.md">TBB Overview</a>, <a href="result.md">Result Type</a>, <a href="../control_flow/error_handling.md">Error Handling</a>
<hr>
<em>Aria Language Project - Sticky Error Propagation by Design</em>
<em>February 12, 2026 - Establishing timestamped prior art on ERR sentinel semantics</em>
    </main>
</body>
</html>
